<html>

<head>
   <meta charset="UTF-8">
   <title>Wrist distance</title>

   <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs"></script>
   <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/posenet"></script>
   <script src="https://unpkg.com/rxjs@^7/dist/bundles/rxjs.umd.min.js"></script>
   <script src="../../lib/bodydetection.js"></script>
   <script src="serial.js"></script>
   
</head>

<body>
   <canvas id="canvas" width="640" height="480"></canvas>
   <video id="video" width="640" height="480" autoplay style="display: none"></video>
   <div id="output"></div>
   <div>
      <p style="text-align: left;">
         <button id="connectBtn">Connect</button>
      </p>
   </div>

   <script>

      // ---- setup and run body detection ----------------------------------------------------
      const bodyStream = new BodyStream({
            posenet: posenet,
            architecture: modelArchitecture.MobileNetV1,
            detectionType: detectionType.singleBody,
            videoElement: document.getElementById('video'),
            samplingRate: 250
      })

      // global
      let body
      let writer
      let port
      let connected = false

      // get elements
      let video = document.getElementById("video")
      let canvas = document.getElementById("canvas")
      let ctx = canvas.getContext("2d")

      // draw the video, nose and eyes into the canvas
      function drawCameraIntoCanvas() {

         // draw the video element into the canvas
         ctx.drawImage(video, 0, 0, video.width, video.height);

         if (body) {
            // draw circle for left and right wrist
            const leftWrist = body.getBodyPart(bodyParts.leftWrist)
            const rightWrist = body.getBodyPart(bodyParts.rightWrist)

            // draw left wrist
            ctx.beginPath()
            ctx.arc(leftWrist.position.x, leftWrist.position.y, 10, 0, 2 * Math.PI)
            ctx.fillStyle = 'white'
            ctx.fill()

            // draw right wrist
            ctx.beginPath()
            ctx.arc(rightWrist.position.x, rightWrist.position.y, 10, 0, 2 * Math.PI)
            ctx.fillStyle = 'white'
            ctx.fill()
         }
         requestAnimationFrame(drawCameraIntoCanvas)
      }

      function serializeBody(body) {

         function serializeBodyPart(name) {
            let bodyPart = body.getBodyPart(name)
            return `:${name},${bodyPart.position.x},${bodyPart.position.y},${bodyPart.speed.absoluteSpeed},${bodyPart.confidenceScore}`
         }

         return Object.values(bodyParts).reduce((prev, curr, index) =>
            index === 1 ? serializeBodyPart(prev) + serializeBodyPart(curr) : prev + serializeBodyPart(curr)
         ) + "\n"
      }

      // listen for bodies detected and send them to microbit if connected
      bodyStream.addEventListener('bodiesDetected', async (e) => {
         body = e.detail.bodies.getBodyAt(0)
         let serializedBody = serializeBody(body)
         // log serialized body
         console.log(serializedBody)

         // send serialized body to microbit if connected
         if (connected) 
            await writer.write(serializedBody)
      })

      // start body detecting 
      bodyStream.start()
    
      // draw video and body parts into canvas continously 
      drawCameraIntoCanvas()
   
      // ---- setup serial connection and send body data when ready -----------------------------------


      // check browser supports serial ports
      if (!"serial" in navigator) {
         alert('Your browser does not support serial ports')
      }

      let connectPortBtn = document.getElementById('connectBtn')
      connectPortBtn.addEventListener('click', async () => {
         if (connected) {
            connectPortBtn.innerText = "Disconnecting..."
            try {
                await writer.releaseLock()
            } catch (err) {
               console.error(err)
            }
            try {
               await writer.close()
            } catch (err) {
               console.error(err)
            }
            try {
               await port.close()
            } catch (err) {
               console.error(err)
            }
            connected = false
         } 
         else {
            try {
               connectPortBtn.innerText = "Connecting..."
               // prompt for which port to use
               port = await navigator.serial.requestPort()
               // open the port
               await port.open({ baudRate: 115200 })
               // pipe a writer to the port
               const textEncoder = new TextEncoderStream()
               const writableStreamClosed = textEncoder.readable.pipeTo(port.writable)
               writer = textEncoder.writable.getWriter()

               connected = true

            } catch (err) {
               console.error(err)
               alert('Could not find/connect to port')
            }
         }
         connected ? connectPortBtn.innerText = "Disconnect" : connectPortBtn.innerText = "Connect"
      })

   </script>
</body>

</html>