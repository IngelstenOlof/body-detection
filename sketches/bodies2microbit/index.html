<html>

<head>
   <meta charset="UTF-8">
   <title>Microbit Serial Communication</title>

   <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs"></script>
   <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/posenet"></script>
   <script src="https://unpkg.com/rxjs@^7/dist/bundles/rxjs.umd.min.js"></script>
   <script src="../../lib/bodydetection.js"></script>

</head>
<style>
   .wrapper {
      display: grid;
      grid-template-columns: 150px 150px 150px 150px;
      grid-template-rows: auto auto auto;
   }
</style>

<body>
   <canvas id="canvas"></canvas>
   <video id="video" autoplay style="display: none"></video>
   <div id="output"></div>
   <div>
      <p style="text-align: left;">
         <button id="connectBtn">Connect</button>
      </p>
      <div class="wrapper" style="display: grid" width="640" style="background-color: red">
         <div class="bodyPartCheck"><input type="checkbox" name="bodyPart" id="nose" checked><label
               for="nose">Nose</label>
         </div>
         <div class="bodyPartCheck"><input type="checkbox" name="bodyPart" id="leftEye"><label for="leftEye">Left
               eye</label></div>
         <div class="bodyPartCheck"><input type="checkbox" name="bodyPart" id="rightEye"><label for="rightEye">Right
               eye</label></div>
         <div class="bodyPartCheck"><input type="checkbox" name="bodyPart" id="leftEar"><label for="leftEar">Left
               ear</label></div>
         <div class="bodyPartCheck"><input type="checkbox" name="bodyPart" id="rightEar"><label for="rightEar">Right
               ear</label></div>
         <div class="bodyPartCheck"><input type="checkbox" name="bodyPart" id="leftShoulder"><label
               for="leftShoulder">Left
               shoulder</label></div>
         <div class="bodyPartCheck"><input type="checkbox" name="bodyPart" id="rightShoulder"><label
               for="rightShoulder">Right shoulder</label></div>
         <div class="bodyPartCheck"><input type="checkbox" name="bodyPart" id="leftElbow"><label for="leftElbow">Left
               elbow</label></div>
         <div class="bodyPartCheck"><input type="checkbox" name="bodyPart" id="rightElbow"><label for="rightElbow">Right
               elbow</label></div>
         <div class="bodyPartCheck"><input type="checkbox" name="bodyPart" id="leftWrist"><label for="leftWrist">Left
               wrist</label></div>
         <div class="bodyPartCheck"><input type="checkbox" name="bodyPart" id="rightWrist"><label for="rightWrist">Right
               wrist</label></div>
         <div class="bodyPartCheck"><input type="checkbox" name="bodyPart" id="leftHip"><label for="leftHip">Left
               hip</label></div>
         <div class="bodyPartCheck"><input type="checkbox" name="bodyPart" id="rightHip"><label for="rightHip">Right
               hip</label></div>
         <div class="bodyPartCheck"><input type="checkbox" name="bodyPart" id="leftKnee"><label for="leftKnee">Left
               knee</label></div>
         <div class="bodyPartCheck"><input type="checkbox" name="bodyPart" id="rightKnee"><label for="rightKnee">Right
               knee</label></div>
         <div class="bodyPartCheck"><input type="checkbox" name="bodyPart" id="leftAnkle"><label for="leftAnkle">Left
               ankle</label></div>
         <div class="bodyPartCheck"><input type="checkbox" name="bodyPart" id="rightAnkle"><label for="rightAnkle">Right
               ankle</label></div>
      </div>
   </div>

   <script>

      // ---- setup and run body detection ----------------------------------------------------
      const bodyStream = new BodyStream({
         posenet: posenet,
         architecture: modelArchitecture.MobileNetV1,
         detectionType: detectionType.singleBody,
         videoElement: document.getElementById('video'),
         samplingRate: 250
      })

      // global
      let bodies
      let writer
      let port
      let count = 0
      let connected = false

      // get elements
      let video = document.getElementById("video")
      let canvas = document.getElementById("canvas")
      let ctx = canvas.getContext("2d")
      video.width = inputResolution.width
      video.height = inputResolution.height
      canvas.height = inputResolution.height
      canvas.width = inputResolution.width

      function bodyPartEnabled(name) {
         return document.getElementById(name).checked
      }

      // draw the video, nose and eyes into the canvas
      function drawCameraIntoCanvas() {

         // draw the video element into the canvas
         ctx.drawImage(video, 0, 0, video.width, video.height);

         if (bodies) {
            bodies.forEach(body => {
               // draw circle for each bodyPart
               const confidenceTreshhold = 0.75
               let yOffset = 20
               let xOffset = 10
               let numOfTexts = 0
               Object.values(bodyParts).forEach(bodyPartName => {
                  if (bodyPartEnabled(bodyPartName)) {


                     let bodyPart = body.getBodyPart(bodyPartName)
                     let { x, y } = bodyPart.position
                     let speed = bodyPart.speed.absoluteSpeed
                     let confidenceScore = bodyPart.confidenceScore

                     // draw body part
                     ctx.beginPath()
                     ctx.arc(x, y, 5, 0, 2 * Math.PI)
                     ctx.fillStyle = `rgba(255, 255, 255, ${confidenceScore})`
                     ctx.fill()
                     ctx.fillStyle = `rgba(255, 255, 153, 1)`
                     ctx.font = "12px 'Arial'"
                     ctx.fillText(`${bodyPartName}`, xOffset, yOffset)
                     ctx.fillText(`x: ${x}`, xOffset, 15 + yOffset)
                     ctx.fillText(`y: ${y}`, xOffset, 30 + yOffset)
                     ctx.fillText(`speed: ${speed}`, xOffset, 45 + yOffset)
                     ctx.fillText(`confidence: ${confidenceScore}`, xOffset, 60 + yOffset)
                     if (yOffset > inputResolution.height - 120) {
                        yOffset = 20
                        xOffset = 130
                     }
                     else {
                        yOffset = yOffset + 80
                     }

                  }
               })
            })
         }
         requestAnimationFrame(drawCameraIntoCanvas)

      }
      function serializeBodyPart(name, body, index) {
         let bodyPart = body.getBodyPart(name)
         return `${name},${bodyPart.position.x},${bodyPart.position.y},${bodyPart.speed.absoluteSpeed},${bodyPart.confidenceScore}\n`
      }



      async function writeAndLog(s) {
         console.log(s)
         if (connected) {
            await writer.write(s)
         }
      }

      // listen for bodies detected and send checked bodyparts to microbit if it is connected
      bodyStream.addEventListener('bodiesDetected', async (e) => {
         // set bodies variable
         bodies = e.detail.bodies.getBodies()
         if (bodies.length > 0) {
            const body = bodies[0]

            bodies.forEach(body => {
               Object.values(bodyParts).forEach((bodyPartName, index) => {
                  if (bodyPartEnabled(bodyPartName))
                     writeAndLog(serializeBodyPart(bodyPartName, body, index))
               })
            })
         }

      })

      // start body detecting 
      bodyStream.start()

      // draw video and body parts into canvas continously 
      drawCameraIntoCanvas()

      // ---- setup serial connection and send body data when ready -----------------------------------


      // check browser supports serial ports
      if (!"serial" in navigator) {
         alert('Your browser does not support serial ports')
      }

      let connectPortBtn = document.getElementById('connectBtn')
      connectPortBtn.addEventListener('click', async () => {
         if (connected) {
            connectPortBtn.innerText = "Disconnecting..."
            try {
               await writer.releaseLock()
            } catch (err) {
               console.error(err)
            }
            try {
               await writer.close()

            } catch (err) {
               console.error(err)
            }
            try {
               await port.close()
            } catch (err) {
               console.error(err)
            }
            connected = false
         }
         else {
            try {
               connectPortBtn.innerText = "Connecting..."
               // prompt for which port to use
               port = await navigator.serial.requestPort()
               // open the port
               await port.open({ baudRate: 115200 })
               // pipe a writer to the port
               const textEncoder = new TextEncoderStream()
               const writableStreamClosed = textEncoder.readable.pipeTo(port.writable)
               writer = textEncoder.writable.getWriter()

               connected = true

            } catch (err) {
               console.error(err)
               alert('Could not find/connect to port')
            }
         }
         connected ? connectPortBtn.innerText = "Disconnect" : connectPortBtn.innerText = "Connect"
      })

   </script>
</body>

</html>