<html>

<head>
   <meta charset="UTF-8">
   <title>Microbit Serial Communication</title>

   <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs"></script>
   <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/posenet"></script>
   <script src="https://unpkg.com/rxjs@^7/dist/bundles/rxjs.umd.min.js"></script>
   <script src="../../lib/bodydetection.js"></script>

</head>

<body>
   <canvas id="canvas" width="640" height="480"></canvas>
   <video id="video" width="640" height="480" autoplay style="display: none"></video>
   <div id="output"></div>
   <div>
      <p style="text-align: left;">
         <button id="connectBtn">Connect</button>
      </p>
   </div>

   <script>

      // ---- setup and run body detection ----------------------------------------------------
      const bodyStream = new BodyStream({
         posenet: posenet,
         architecture: modelArchitecture.MobileNetV1,
         detectionType: detectionType.singleBody,
         videoElement: document.getElementById('video'),
         samplingRate: 1000
      })

      // global
      let body
      let writer
      let port
      let count = 0
      let connected = false

      // get elements
      let video = document.getElementById("video")
      let canvas = document.getElementById("canvas")
      let ctx = canvas.getContext("2d")

      // draw the video, nose and eyes into the canvas
      function drawCameraIntoCanvas() {

         // draw the video element into the canvas
         ctx.drawImage(video, 0, 0, video.width, video.height);

         if (body) {
            // draw circle for left and right wrist
            const leftWrist = body.getBodyPart(bodyParts.leftWrist)
            const rightWrist = body.getBodyPart(bodyParts.rightWrist)

            // draw left wrist
            ctx.beginPath()
            ctx.arc(leftWrist.position.x, leftWrist.position.y, 10, 0, 2 * Math.PI)
            ctx.fillStyle = 'white'
            ctx.fill()

            // draw right wrist
            ctx.beginPath()
            ctx.arc(rightWrist.position.x, rightWrist.position.y, 10, 0, 2 * Math.PI)
            ctx.fillStyle = 'white'
            ctx.fill()
         }
         requestAnimationFrame(drawCameraIntoCanvas)
      }


      function serializeBodyPart(name, body) {
         let bodyPart = body.getBodyPart(name)
         return `${name},${bodyPart.position.x},${bodyPart.position.y},${bodyPart.speed.absoluteSpeed},${bodyPart.confidenceScore}\n`
      }



      async function writeAndLog(s) {
         console.log(s)
         if (connected) {
            await writer.write(s)
         }
      }

      // listen for bodies detected and send them to microbit if connected
      bodyStream.addEventListener('bodiesDetected', async (e) => {



         body = e.detail.bodies.getBodyAt(0)

         writeAndLog(serializeBodyPart(bodyParts.nose, body))
         writeAndLog(serializeBodyPart(bodyParts.leftEye, body))
         writeAndLog(serializeBodyPart(bodyParts.rightEye, body))
         //     writeAndLog(serializeBodyPart(bodyParts.leftShoulder, body))
         //      writeAndLog(serializeBodyPart(bodyParts.rightShoulder, body))

      })

      // start body detecting 
      bodyStream.start()

      // draw video and body parts into canvas continously 
      drawCameraIntoCanvas()

      // ---- setup serial connection and send body data when ready -----------------------------------


      // check browser supports serial ports
      if (!"serial" in navigator) {
         alert('Your browser does not support serial ports')
      }

      let connectPortBtn = document.getElementById('connectBtn')
      connectPortBtn.addEventListener('click', async () => {
         if (connected) {
            connectPortBtn.innerText = "Disconnecting..."
            try {
               await writer.releaseLock()
            } catch (err) {
               console.error(err)
            }
            try {
               await writer.close()

            } catch (err) {
               console.error(err)
            }
            try {
               await port.close()
            } catch (err) {
               console.error(err)
            }
            connected = false
         }
         else {
            try {
               connectPortBtn.innerText = "Connecting..."
               // prompt for which port to use
               port = await navigator.serial.requestPort()
               // open the port
               await port.open({ baudRate: 115200 })
               // pipe a writer to the port
               const textEncoder = new TextEncoderStream()
               const writableStreamClosed = textEncoder.readable.pipeTo(port.writable)
               writer = textEncoder.writable.getWriter()

               connected = true

            } catch (err) {
               console.error(err)
               alert('Could not find/connect to port')
            }
         }
         connected ? connectPortBtn.innerText = "Disconnect" : connectPortBtn.innerText = "Connect"
      })

   </script>
</body>

</html>